#define  _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
/*
int main() {
	int a = 10;
	//00000000 00000000 00000000 00001010 原码
	//00000000 00000000 00000000 00001010 反码
	//00000000 00000000 00000000 00001010 补码
	//0x000000A

	int b = -2;
	//10000000 00000000 00000000 00000010 原码
	//11111111 11111111 11111111 11111101 反码 
	//11111111 11111111 11111111 11111110 补码
	//fffffffE


	//指针的大小决定了指针读取内存空间的大小
	//从内存的低地址开始读取
	int p = 0x11223344;  //44 33 22 11
	//int* q = &p;
	//*q= 0;  //00 00 00 00

	char* u = &p;
	*u = 0;//00 33 22 11

}

*/
/*
//设计一个程序判断字节存储方式；
//int check_sys() {
// int a=1;
//	char* p = (char*)&a;//只取出一个字节的内容来判断
//	if (*p == 1)return 1;
//	else return 0;
//}

int check_sys() {//y优化
	int a = 1;
	char* p = (char*)&a;//只取出一个字节的内容来判断
	return *p;  //return (*(char*)&a);
}
int main() {
	//判断的话，用一个较为特殊的地址可以判断；
	
	int ret=check_sys();
	if (ret)printf("小端");
	else printf("da");

	return 0;
}*/


//int main() {
//	char a = -1;
//	//10000000 00000000 00000000 00000001原码
//	//11111111111111111111111111111110  反码
//	//11111111111111111111111111111111 补码
//
//	signed char b = -1;
//	//11111111
//	//11111111111111111111111111111111 补码
//	//10000000000000000000000000000001//dayin原码
//
//	unsigned  char c = -1;
//	//11111111							//补码
//	//00000000000000000000000011111111  //原码
//	printf("%d %d %d", a, b, c);//-1 -1 255
//
//	char aa = -128;
//	//10000000 00000000 00000000 10000000
//	//11111111 11111111 11111111 01111111
//	//11111111 11111111 11111111 10000000// buma
//
//	//10000000因为a为字节类型，所以截取一个字节，，打印的时候补回32位，最高位补符号位-无符号数
//	//11111111 11111111 11111111 10000000 //打印的时候，直接换算位十进制，不用再换位原码
//	printf(" %u", aa); //打印十进制的无符号数
//	//无符号数的原码和补码相同
//
//	char bb = 128;
//	//00000000 00000000 00000000 10000000//128原码
//	//一个字符，截取8位 10000000
//	//打印无符号数，将高位补位32，补为最高位
//	//11111111 11111111 11111111 10000000  /还原为原码为……
//	printf("%u" ,bb);
//}


//#include <windows.h>  //使用sleep函数的时候，必须引入此头文件
//unsigned char i = 0;
//int main() {
//	for (i = 0; i <= 255; i++) {
//		printf("%d\n", i);//循环输出0~255
//		Sleep(100);
//	}
//	return 0;
//}


//浮点型的数据存储
int main() {
	double d = 1E10;
	printf("%lf\n", d);//10000000000.000000

	//指针和int型都是4个字节，都能读取改空间的内容
	int n = 9;
	//1 00000000 0000000 0000 0000 0000 1001 //正数的原码和反码补码都一致
	printf("%d:\n", n); //9

	float* p = (float*)&n;
	//(-1)^0*0.0000000 0000 0000 0000 1001*2^-126
	printf("*p=%f\n", *p);

	* p = 9.0;
	//1001.0
	//1.001*2^3
	// 	   E=127+3=130指数存储130
	//0 10000010 001 0000 0000 0000 0000 0000 //如果以十进制读取的话，就直接将此二进制转换为十进制1,091,567,616
	//(-1)^0*1.001*2^3
	printf("%d:\n", n);
	printf("*p=%f\n", *p);

	/*	
		9:
		*p=0.000000
		1091567616:
		*p=9.000000
	*/

	/*
	//负整数的浮点型读取
	int n = -9;
	//1 00000000 0000000 0000 0000 0000 1001 //-9的原码
	//1 11111111 1111111 1111 1111 1111 0111  //-9补码
	printf("%d:\n", n);

	float* p = (float*)&n; //-9 
	//如果以浮点型读取-9，将直接把内存中补码形式读取为浮点的标准式
	//(-1)^(1)*1.0*2^128  //表示无穷大，所以显示nan
	printf("*p=%f\n", *p);//*p=-nan

	*/
}



//int main() {
//	float t = 5.5;
//	printf("%p\n", &t);
//	/*101.1;
//	1.011*2^2
//	->S=0;M=1.011;E=2  E=2+127
//	0 10000001 011 0000 0000 0000 0000 0000
//	0x 40B00000*/
//	return 0;
//}